<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DoodleDuel Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <style>
        /* 1. Fix the "Jump" bug - locks the screen */
        html, body { 
            position: fixed; 
            overflow: hidden; 
            width: 100%; 
            height: 100%; 
            background: #5a8fd4; 
            font-family: sans-serif;
            margin: 0; padding: 0;
        }
        
        #ui-layer {
            display: flex;
            flex-direction: column;
            height: 100%;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
        }

        #header { color: white; font-weight: bold; margin-bottom: 5px; font-size: 20px; }

        /* 2. Fix the "Alignment" bug */
        #canvas-wrap {
            background: white;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 4/3;
            border-radius: 10px;
            position: relative;
            touch-action: none; /* Stops iPhone from scrolling while drawing */
        }

        canvas { width: 100%; height: 100%; border-radius: 10px; display: block; }

        .controls {
            display: flex;
            width: 100%;
            max-width: 400px;
            gap: 10px;
            margin: 10px 0;
        }

        .chat-box {
            background: white;
            width: 100%;
            max-width: 400px;
            flex-grow: 1;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            margin-bottom: env(safe-area-inset-bottom); /* Fixes notch/bottom bar overlap */
        }

        #msgs { flex-grow: 1; overflow-y: auto; padding: 10px; font-size: 14px; }
        input { 
            padding: 15px; 
            border: none; 
            border-top: 1px solid #ddd; 
            font-size: 16px; /* 16px prevents iOS auto-zoom */
            outline: none;
        }

        button { padding: 10px 15px; border-radius: 8px; border: none; font-weight: bold; }
        .active { background: #43b02a; color: white; }
    </style>
</head>
<body>

<div id="ui-layer">
    <div id="header">WORD: BANANA</div>

    <div id="canvas-wrap">
        <canvas id="mc"></canvas>
    </div>

    <div class="controls">
        <input type="color" id="col" value="#000000" style="width:50px; padding:0;">
        <button id="bBtn" class="active" onclick="setT('brush')">üñåÔ∏è</button>
        <button id="kBtn" onclick="setT('bucket')">ü™£</button>
        <button onclick="clr()" style="background:#ff4757; color:white; margin-left:auto;">CLEAR</button>
    </div>

    <div class="chat-box">
        <div id="msgs"></div>
        <input type="text" id="gin" placeholder="Type guess here...">
    </div>
</div>

<script>
    const canvas = document.getElementById('mc');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const gin = document.getElementById('gin');
    const msgs = document.getElementById('msgs');
    let drawing = false, tool = 'brush';

    // 3. Perfect Coordinate Scaling
    function resize() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * window.devicePixelRatio;
        canvas.height = rect.height * window.devicePixelRatio;
        ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }
    window.addEventListener('load', resize);
    window.addEventListener('resize', resize);

    function getP(e) {
        const rect = canvas.getBoundingClientRect();
        const t = e.touches ? e.touches[0] : e;
        return {
            x: t.clientX - rect.left,
            y: t.clientY - rect.top
        };
    }

    const start = (e) => {
        const p = getP(e);
        if(tool === 'bucket') {
            fill(Math.floor(p.x), Math.floor(p.y), document.getElementById('col').value);
        } else {
            drawing = true;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
        }
    };

    const move = (e) => {
        if(!drawing || tool !== 'brush') return;
        const p = getP(e);
        ctx.lineTo(p.x, p.y);
        ctx.strokeStyle = document.getElementById('col').value;
        ctx.lineWidth = 4; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.stroke();
    };

    canvas.addEventListener('touchstart', start, {passive: false});
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); move(e); }, {passive: false});
    canvas.addEventListener('touchend', () => drawing = false);

    gin.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            const v = gin.value.toUpperCase().trim();
            if(v === "BANANA") {
                msgs.innerHTML += "<div style='color:green'><b>üèÜ CORRECT!</b></div>";
                confetti();
            } else if(v !== "") {
                msgs.innerHTML += "<div>" + v + "</div>";
            }
            gin.value = "";
            msgs.scrollTop = msgs.scrollHeight;
        }
    });

    function setT(t) {
        tool = t;
        document.getElementById('bBtn').className = t === 'brush' ? 'active' : '';
        document.getElementById('kBtn').className = t === 'bucket' ? 'active' : '';
    }

    function clr() { ctx.clearRect(0,0,canvas.width,canvas.height); }

    function fill(startX, startY, color) {
        const rect = canvas.getBoundingClientRect();
        const w = Math.floor(rect.width), h = Math.floor(rect.height);
        const img = ctx.getImageData(0, 0, w * window.devicePixelRatio, h * window.devicePixelRatio);
        const data = img.data;
        
        // Pixel-perfect filling logic
        const hexToRgb = (hex) => {
            const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
            return [r, g, b];
        }
        const fC = hexToRgb(color);
        const x = Math.floor(startX * window.devicePixelRatio);
        const y = Math.floor(startY * window.devicePixelRatio);
        const i = (y * img.width + x) * 4;
        const sR = data[i], sG = data[i+1], sB = data[i+2];

        if(sR===fC.r && sG===fC.g && sB===fC.b) return;

        const stack = [[x, y]];
        while(stack.length) {
            const [cx, cy] = stack.pop();
            const idx = (cy * img.width + cx) * 4;
            if(data[idx]===sR && data[idx+1]===sG && data[idx+2]===sB) {
                data[idx]=fC.r; data[idx+1]=fC.g; data[idx+2]=fC.b; data[idx+3]=255;
                if(cx>0) stack.push([cx-1, cy]);
                if(cx<img.width-1) stack.push([cx+1, cy]);
                if(cy>0) stack.push([cx, cy-1]);
                if(cy<img.height-1) stack.push([cx, cy+1]);
            }
        }
        ctx.putImageData(img, 0, 0);
    }
</script>
</body>
</html>
